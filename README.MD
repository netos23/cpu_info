# Экспериментальное определение характеристик кеша L1
___
<!-- TOC -->
* [Экспериментальное определение характеристик кеша L1](#экспериментальное-определение-характеристик-кеша-l1)
    * [Сборка](#сборка)
        * [Сборка с помощью cmake](#сборка-с-помощью-cmake)
        * [Ручная сборка](#ручная-сборка)
    * [Использование](#использование)
    * [Принцип работы](#принцип-работы)
        * [Общий принцип работы](#общий-принцип-работы)
        * [1. Определение размера кеша L1](#1-определение-размера-кеша-l1)
        * [2. Определение ассоциативности](#2-определение-ассоциативности)
        * [3. Определение длины линейки кеша](#3-определение-длины-линейки-кеша)
    * [Экспириментально полученные значения](#экспириментально-полученные-значения)
<!-- TOC -->


## Сборка
___

### Сборка с помощью cmake

``` bash
   cmake -S . -B cmake-build-release -G "Unix Makefiles" -DCMAKEBUILDTYPE=Release
   cd cmake-build-release
   make
```

### Ручная сборка

```bash
    mkdir bin
    clang++ -O2 -std=c++17 main.cpp -o ./bin/cpu_info
```

## Использование
___
```
 Использование: cpu_info [-v] [-i <int>|-i<int>] [-r <int>|-r<int>]
  -v         Включает подробный режим
  -i <int>   Количество итераций обхода данных
  -r <int>   Количество прогонов вычислений
  -h, --help Показать справку
```

## Принцип работы
___
### Общий принцип работы
Выстраивается кольцо из указателей последовательное или рандомное, затем производиться n замеров для определенного 
целевого значения. В каждом замере сначала выполняется прогрев, после чего выполняется замер основного цыкла, после 
данные замеров по целевому значению агрегируются (усредняются или берется минимальное). По получиным данным для всех 
иследуемых значений ищется ступенька с помощью определенной эвристики.
### 1. Определение размера кеша L1
Пока массив помещается в L1, доступ быстрый; когда размер превышает L1, латентность заметно растёт (переход на L2).
### 2. Определение ассоциативности
Создаём набор адресов, которые (с большой вероятностью) попадают в один и тот же set L1, и меряем время прохода по 
кольцу указателей при количестве линий k.
Предполагаем что адреса, отличающиеся на размер страницы памяти (4K/16K), имеют одинаковые 
 set. Когда иследуемое значение асоциативности превышает фактическую 
ассоциативность, начинаются конфликтные промахи 
и время растёт.
### 3. Определение длины линейки кеша
Выстраеваем кольцо указателей с шагом в длину линейки кеша(stride). При stride меньше размера cache line несколько 
узлов попадают в одну линию кэша ⇒ один промах “амортизируется” несколькими попаданиями 
⇒ время на один переход меньше. При stride ≥ cache line почти каждый переход затрагивает новую линию ⇒ время растёт.

## Экспириментально полученные значения

| Процессор           | Размер страницы памяти(KB) | Размер L1(KB) | Асоциативность | Длина линейки(B) |
|---------------------|----------------------------|---------------|----------------|------------------|
| Apple M1 (8GPU)     | 16                         | 128           | 8              | 128              |
| Intel Core i5 8250U | 4                          | 32            | 8              | 64               |
